# {"metadata": "v1.0", "at": "2025-09-11T09:24:08.659641Z", "by": "app.fab.make_range.main>make_range>make_one>run_pipeline>get_metadata", "triples": 43, "entities": 11, "chars": 2911}
@prefix cnt: <http://www.w3.org/2011/content#> .
@prefix oeis: <http://www.oeis.org/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix seq: <http://www.seqweb.org/> .

oeis:A383038 a seq:Sequence ;
    rdfs:label "A383038"@en ;
    seq:hasTextList ( seq:A383038_I_1_20250429T165316 seq:A383038_N_1_20250429T165316 seq:A383038_C_1_20250429T165316 seq:A383038_e_1_20250429T165316 seq:A383038_o_1_20250429T165316 seq:A383038_Y_1_20250429T165316 seq:A383038_K_1_20250429T165316 seq:A383038_O_1_20250429T165316 seq:A383038_A_1_20250429T165316 seq:A383038_V_1_20250429T165316 ) .

seq:A383038_A_1_20250429T165316 a seq:Text ;
    cnt:chars "_Boas Bakker_, Apr 13 2025"@en .

seq:A383038_C_1_20250429T165316 a seq:Text ;
    cnt:chars """Terms are all even because b^r - b^s == b - b == 0 (mod 2).
From _David A. Corneth_, Apr 26 2025: (Start)
By definition, b, s, r and b^r - b^s is positive. Therefore, r > s. If b = 1 then b^r - b^s = 1^r - 1^s = 0 which is excluded by default so b > 1. Suppose we look for terms <= U. Then b is maximal when (s, r) = (1, 2) i.e. b^2 - b <= U. Solving for b gives (sqrt(4*U + 1) + 1) / 2.
As r > s >= 1, r >= 2.
Once b is fixed, b^r - b^s is minimal when s = r-1, enabling the largest r.
So we'd have b^r - b^(r-1) = (b - 1)*(b^(r-1)) <= U. Solving for r gives r <= log(U / (b - 1)) / log(b) + 1.
Once b and r are fixed we have
b^r - b^s <= U so b^r - U <= b^s. Solving for s gives log(b^r - U) / log(b) <= s.
Summarizing we have
2 <= b <= (sqrt(4*U + 1) + 1) / 2,
2 <= r <= log(U / (b - 1)) / log(b) + 1,
log(b^r - U) / log(b) <= s <= r-1. (End)"""@en .

seq:A383038_I_1_20250429T165316 a seq:Text ;
    cnt:chars "#28 Apr 29 2025 16:53:16"@en .

seq:A383038_K_1_20250429T165316 a seq:Text ;
    cnt:chars "nonn,new"@en .

seq:A383038_N_1_20250429T165316 a seq:Text ;
    cnt:chars "Positive integers which can be expressed in the form b^r - b^s where b, r, and s are positive integers."@en .

seq:A383038_O_1_20250429T165316 a seq:Text ;
    cnt:chars "1,1"@en .

seq:A383038_V_1_20250429T165316 a seq:Text ;
    cnt:chars "2,4,6,8,12,14,16,18,20,24,28,30,32,42,48,54,56,60,62,64,72,78,90,96,100,110,112,120,124,126,128,132,156,162,180,182,192,210,216,224,234,240,248,252,254,256,272,294,306,336,342,380,384,420,448,462,480,486,496,500"@en .

seq:A383038_Y_1_20250429T165316 a seq:Text ;
    cnt:chars "The terms of the case b=2 are in A043569."@en .

seq:A383038_e_1_20250429T165316 a seq:Text ;
    cnt:chars """a(6) = 14 = 16 - 2 = 2^4 - 2^1.
a(9) = 20 = 25 - 5 = 5^2 - 5^1.
As _David A. Corneth_ said, we know r > s > 0 and b > 1, so r > 1, and the smallest value of b is 2. So b^r - b^s >= b^(r-1) >= 2^(r-1). So to prove 10 is not in the sequence, we only need to check up up to r=4, because for r=5, 2^(s-1) = 2^4 = 16 > 10. This means there are 6 combinations of (r, s) we need to check. We also know b^r - b^s == 0 (mod b) because s > 0, so we only need to check divisors of 10. So with b = 2 and s < r < 5, we get the terms {2, 4, 6, 8, 12, 14}. With b=5 the smallest term is 5^2 - 5^1 = 20, which is bigger than 10. For b>5, b^r - b^s >= b^2 - b > 5^2 - 5, so we don't need to check those values of b."""@en .

seq:A383038_o_1_20250429T165316 a seq:Text ;
    cnt:chars """(PARI) upto(n) = {n++; my(res = List());
    maxb = ceil((sqrtint(4*n + 1) + 1) / 2);
    for(b = 2, maxb,
        maxr = logint(n\\(b-1), b) + 1;
        for(r = 2, maxr,
            mins = max(1, ceil(log(max(b^r - n, 1)) / log(b)));
            mins = min(mins, r-1); \\\\ min() to fix messed up rounding when b^r - n is a power of b. Also solved by increasing n by 1 initially (n++).
            forstep(s = r-1, mins, -1,
                c = b^r - b^s;
                listput(res, c);
            );
        );
    );
    Set(res)
} \\\\ _David A. Corneth_, Apr 26 2025
(Python)
from sympy import integer_nthroot
aupto = 500
b_max, A383038 = (i := integer_nthroot(aupto,2))[0] + 2 - i[1], set()
for b in range(2, b_max):
    r, s = 2, 1
    while (br:=b**r) - b**s <= aupto:
        while s > 0 and (res := br - b**s) <= aupto: A383038.add(res); s -= 1
        r += 1
        s = r - 1
print(sorted(A383038)) # _Karl-Heinz Hofmann_, Apr 29 2025"""@en .

